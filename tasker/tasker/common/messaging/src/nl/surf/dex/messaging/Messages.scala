package nl.surf.dex.messaging

import io.circe.generic._
import nl.surf.dex.messaging.Messages.TaskProgress.State
import nl.surf.dex.storage.Share

/**
  * Messages used in the DataExchange messaging protocol
  */
object Messages {

  case class StartContainer(
      /**
        * Id of the task generated by the client. Tasker doesn't require them to be unique,
        * but in order for the client to make sense of "Done" messages, they'd better be.
        */
      taskId: String,
      /**
        * Relative path to the data set.
        */
      dataLocation: Share.Location,
      /**
        * Relative path to the algorithm code.
        */
      codeLocation: Share.Location,
      /**
        * Hash of the algorithm. If passed-will be checked before the task is started,
        * and if it doesn't match - task will be rejected.
        */
      codeHash: Option[String]
  )

  case class TaskProgress(
      /**
        * Id of the task.
        */
      taskId: String,
      /**
        * Current state of the task.
        */
      state: State
  )

  object TaskProgress {

    object codecs extends extras.AutoDerivation {
      import extras.Configuration
      implicit val customConfig: Configuration =
        Configuration.default
          .withDiscriminator("name")
    }

    sealed trait State

    object State {
      case class Rejected(reason: String) extends State
      case class Running(currentStepIndex: Int, currentStep: Step) extends State
      case class Success(output: AlgorithmOutput) extends State
      case class Error(
          message: String,
          output: AlgorithmOutput,
          failedStep: Step
      ) extends State
    }

    def running(taskId: String, step: Step): TaskProgress =
      TaskProgress(
        taskId,
        State.Running(Step.stepsOrder.indexOf(step, 0), step)
      )

    def success(
        taskId: String,
        containerOutput: AlgorithmOutput
    ): TaskProgress =
      TaskProgress(taskId, State.Success(containerOutput))

    def error(
        taskId: String,
        message: String,
        containerOutput: AlgorithmOutput,
        failedStep: Step
    ): TaskProgress =
      TaskProgress(taskId, State.Error(message, containerOutput, failedStep))

    def rejected(taskId: String, reason: String): TaskProgress =
      TaskProgress(taskId, State.Rejected(s"Task has been rejected: '$reason'"))

    def rejected(taskId: String, reason: Throwable): TaskProgress =
      TaskProgress(
        taskId,
        State.Rejected(s"Task has been rejected: '${reason.getMessage}'")
      )

    def rejectedDueToHash(taskId: String): TaskProgress =
      rejected(
        taskId,
        "The algorithm mush have changed since approval. Hash doesn't match."
      )
  }

  case class AlgorithmOutput(
      /**
        * Standard output produced by the user Python script
        */
      stdout: String,
      /**
        * Standard error produced by the user Python script
        */
      stderr: String,
      /**
        * Strace produced by the user Python script
        */
      strace: String
  )

  sealed trait Step

  object Step {

    case object VerifyingAlgorithm extends Step
    case object DownloadingFiles extends Step
    case object InstallingDependencies extends Step
    case object CreatingContainer extends Step
    case object ExecutingAlgorithm extends Step
    case object CleaningUp extends Step

    val stepsOrder: List[Step] = List(
      VerifyingAlgorithm,
      DownloadingFiles,
      InstallingDependencies,
      CreatingContainer,
      ExecutingAlgorithm,
      CleaningUp
    )
  }

}
