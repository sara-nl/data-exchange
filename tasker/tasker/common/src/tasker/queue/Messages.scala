package tasker.queue

import io.circe.generic.extras.AutoDerivation

/**
  * Messages used in the DataExchange messaging protocol
  */
object Messages {

  object implicits extends AutoDerivation {

    import io.circe.generic.extras.Configuration
    implicit val customConfig: Configuration = Configuration.default
      .withDiscriminator("name")
  }

  case class ETag(eTag: String)

  case class StartContainer(
                            /**
                              * Id of the task generated by the client. Tasker doesn't require them to be unique,
                              * but in order for the client to make sense of "Done" messages, they'd better be.
                              */
                            taskId: String,
                            /**
                              * Relative path to the data set.
                              */
                            dataPath: String,
                            /**
                              * Relative path to the algorithm code.
                              */
                            codePath: String,
                            /**
                              * Hash of the algorithm. If passed-will be checked before the task is started,
                              * and if it doesn't match - task will be rejected.
                              */
                            codeHash: ETag)

  case class TaskProgress(
                          /**
                            * Id of the task.
                            */
                          taskId: String,
                          /**
                            * Current state of the task.
                            */
                          state: State)

  object TaskProgress {

    def running(taskId: String, step: Step): TaskProgress =
      TaskProgress(
        taskId,
        State.Running(Step.stepsOrder.indexOf(step, 0), step)
      )

    def success(taskId: String,
                containerOutput: AlgorithmOutput): TaskProgress =
      TaskProgress(taskId, State.Success(containerOutput))

    def error(taskId: String,
              message: String,
              containerOutput: AlgorithmOutput,
              failedStep: Step): TaskProgress =
      TaskProgress(taskId, State.Error(message, containerOutput, failedStep))

    def rejected(taskId: String, reason: String): TaskProgress =
      TaskProgress(taskId, State.Rejected(s"Task has been rejected: '$reason'"))

    def rejected(taskId: String, reason: Throwable): TaskProgress =
      TaskProgress(
        taskId,
        State.Rejected(s"Task has been rejected: '${reason.getMessage}'")
      )

    def rejectedEtag(taskId: String): TaskProgress =
      rejected(
        taskId,
        "The algorithm mush have changed since approval. ETag doesn't match."
      )
  }

  case class AlgorithmOutput(
                             /**
                               * Standard output produced by the user Python script
                               */
                             stdout: String,
                             /**
                               * Standard error produced by the user Python script
                               */
                             stderr: String,
                             /**
                               * Strace produced by the user Python script
                               */
                             strace: String)

  sealed trait Step

  object Step {

    case object VerifyingAlgorithm extends Step
    case object DownloadingFiles extends Step
    case object InstallingDependencies extends Step
    case object CreatingContainer extends Step
    case object ExecutingAlgorithm extends Step
    case object CleaningUp extends Step

    val stepsOrder: List[Step] = List(
      VerifyingAlgorithm,
      DownloadingFiles,
      InstallingDependencies,
      CreatingContainer,
      ExecutingAlgorithm,
      CleaningUp
    )
  }

  sealed trait State

  object State {
    case class Rejected(reason: String) extends State
    case class Running(currentStepIndex: Int, currentStep: Step) extends State
    case class Success(output: AlgorithmOutput) extends State
    case class Error(message: String, output: AlgorithmOutput, failedStep: Step)
        extends State
  }

}
